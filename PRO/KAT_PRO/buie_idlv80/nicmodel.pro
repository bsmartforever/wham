;+
; NAME:
;    nicmodel
; PURPOSE: (one line)
;    Generate synthetic PSF images for the HST NICMOS Camera
; DESCRIPTION:
;    A generated PSF is added to the output array.  If the array is not
; defined, it is created with dimensions 256 by 256.  Successive calls
; will add objects (PSF's) to the array.
; CATEGORY:
;  CCD data processing
; CALLING SEQUENCE:
;    nicmodel, camera, xsrc, ysrc, inten, filter, bmvnum, back, image
; INPUTS:
;    camera  : Camera number (1, 2, or 3)
; xsrc, ysrc : Position of the PSF in the output array.
;    inten   : Intensity of PSF relative to TinyTim output PSF
;    filter  : Filter name in the form Fxxx(W,LP,M,N).
;    bmvnum  : B-V list value (TinyTim V6.2 values):
;                BMVNUM    TYPE       B-V
;                1           O5      -0.34
;                2           O8F     -0.32
;                3           O6      -0.31
;                4           B1V     -0.27
;                5           B3V     -0.21
;                6           B6V     -0.12
;                7           A0V     -0.04
;                8           A5V      0.12
;                9           F6V      0.37
;               10           F8V      0.48
;               11           G2V      0.56
;               12           G5V      0.66
;               13           G8V      0.75
;               14           K4V      0.92
;               15           K7V      1.28
;               16           M1.5V    1.45
;               17           M3V      1.44
;    back    : Background to be added.
;
; KEYWORD PARAMETERS:
;  GRID      : Grid spacing for psf files.
;  HSTPATH   : Alternate path for HST PSF's.
;  JITTER    : If set contains the gaussian smearing to apply to the image.
;                This is in units of 1/e half width.  If not set, no smearing
;                is applied. This calculation is done in double precision
;                or float according to the type of image. The values passed
;                to the exp function ( e - (((x/j)^2 + y/j)^2/2)) are 
;                restricted to a maximum based on the computational precision
;                to avoid floating point underflow.
;               
;  NEW       : If set, clears the output array to zeros before building the
;              PSF image(s).
;
;  OBJRAD    : Radius of object in pixels.  If not set, assumed to be a point
;              source.  If set and radius is greater than 0.5, then PSF is
;              convolved with a circular function of this radius.  This models
;              the object as a Lambert disk, crude but useful for barely
;              resolved objects.
;  PSFSIZE   : Size of requested PSF, in arcseconds (default: 5).
;  SAMPFACT  : Sample factor (default: 6).
;  VERBOSE   : If set, prints informational message.
;  Z4        : setting for fourth (focus) Zernicke coefficient. If not set,
;              the default value for the WFPC2 instrument generated by HSTPSF 
;              will be used.
;
; OUTPUTS:
;    image  : The image array into which the PSF is placed.
; COMMON BLOCKS:
;
; SIDE EFFECTS:
;
; RESTRICTIONS:
;
; PROCEDURE:
;    The Tiny Tim programs are used, via the procedure HSTPSF, to generate
; a (usually) 2X (7.5 micron spacing) PSF at the nearest grid location to the 
; requested position. (This grid and default spacing are defined in hstpsf).
;    From the interpolated maximum returned by hstpsf, shift amounts for x
; and y are computed.
;    The PSF is shifted by these amounts and then compressed to a 1X
; (15 micron spacing) PSF.
;    Finally, the resulting PSF is multiplied by the intensity parameter and
; added into the output array.
;    Calls external procedures BADPAR, BOXM, HSTPSF, and SSHIFT2D.
; MODIFICATION HISTORY:
;      cloned from pc2model.pro
;  2010/08/25, Written by Marc W. Buie, Southwest Research Institute
;-
pro nicmodel, camera, xsrc_in, ysrc_in, inten,  filter, bmvnum, back, in_image,$
             GRID=grid, $
             HSTPATH=hstpath,$
             JITTER=jitter_in,$
             NEW=new,$
             OBJRAD=objrad, $
             PSFSIZE=psfsize, $
             SAMPFACT=sampfact, $
             VERBOSE=verbose, $
             Z4=z4

   if n_params() lt 7 then begin
      print, 'nicmodel, xsrc, ysrc, inten, filter, bmvnum, back, image'
      return
   endif

   self = 'NICMODEL: '
   if badpar(xsrc_in,[2,3,4,5],[0,1],caller=self+'(xsrc) ',npts=n1) then return
   if badpar(ysrc_in,[2,3,4,5],[0,1],caller=self+'(ysrc) ',npts=n2) then return
   if badpar(inten,[2,3,4,5],[0,1],caller=self+'(inten) ',npts=n3) then return

   ; Check arguments.
   if badpar(filter, 7,       0,     caller=self+'(filter) ') then return
   if badpar(bmvnum, [2,3],   0,     caller=self+'(bmvnum) ') then return
   if badpar(back,   [2,3,4,5], 0,   caller=self+'(back) ') then return

   ; Check keyword parameters.
   if badpar(hstpath, [0,7], 0, caller=self+'(hstpath) ') then return
   if badpar(new, [0,2], 0, caller=self+'(new) ', default=0) then return
   if badpar(grid, [0,2,3], 0, caller=self+'(GRID) ',default=10) then return

   if badpar(objrad, [0,2,3,4,5], [0,1], caller=self+'(objrad) ',$
             npts=n4) then return
   if badpar(z4,   [0,4,5], 0,   caller=self+'(Z4) ' ) then return
   if badpar(jitter_in,   [0,4,5], 0,   caller=self+'(JITTER) ', $
             default=0.0) then return
   if badpar(sampfact, [0,1,2,3], 0, caller=self+'(SAMPFACT) ', $
             default=6) then return
   if badpar(psfsize, [0,2,3,4,5], 0, caller=self+'(psfsize) ', $
             default=5.) then return

   if badpar(verbose, [0,2], 0, caller=self+'(verbose) ', default=0) then return

   if camera eq 1 then begin
      tcam=19
   endif else if camera eq 2 then begin
      tcam=20
   endif else if camera eq 3 then begin
      tcam=21
   endif else begin
      print,self,'Camera ',strn(camera),' is not supported.'
      return
   endelse

   ; Check that the input parameters have equal length.
   t = [n1, n2, n3]

   if max(t) ne min(t) then begin
      msg=self +  $
        'Error. xsrc, ysrc, and intensity parameters must have the same length.'
      print, msg
      return
   endif

   ; Verify valid OBJRAD if supplied
   if n_elements(objrad) ne 0 and n4 ne n1 then begin
      msg=self+ $
      'Error. OBJRAD must have the same length as the xsrc and ysrc parameters.'
      print, msg
      return
   endif

   xsrc = xsrc_in
   ysrc = ysrc_in

   stat = size(in_image)
   imgtype = size(in_image,/TYPE)
   ndim = stat[0]

   if ndim ne 2 then begin
      ; The output array must be created.
      im_xsize = 256
      im_ysize = 256
      in_image = fltarr(im_xsize, im_ysize)
      imgtype=4
   endif else begin
      ; It exists.  Get its dimensions.
      im_xsize = stat[1]
      im_ysize = stat[2]
   endelse

   image = fltarr(im_xsize, im_ysize)

   for j=0, n1-1 do begin
      if verbose then begin
         print,self, 'Working on object at ' + string(xsrc[j], ysrc[j], $
         format='(2F12.4)')
      endif

      date = ''    ; not used, but must be defined.
      hstpsf, xsrc[j], ysrc[j], date, filter, bmvnum, psf, xm, ym, $
              HSTPATH=hstpath, PSFSIZE=psfsize, SAMPFACT=sampfact, $
              CAMERA=tcam, Z4=z4, GRID=grid,  VERBOSE=verbose

      psfstat = size(psf)

      if psfstat[0] lt 2 then begin
         print, self, 'Error: Procedure HSTPSF did not return a PSF array '
         return
      endif

      ; size of the sub-sampled PSF
      psf_xsizef = psfstat[1]
      psf_ysizef = psfstat[2]

      ; xm,ym tells us the location of the peak of the numerical PSF within the
      ;  sub-sampled pixel grid in the array "psf".  Now, compute where that
      ;  peak would fall if the PSF were to be downsampled to the output image
      ;  grid scale.
      xm0 = (xm - float(sampfact)/2.0 + 0.5)/float(sampfact)
      ym0 = (ym - float(sampfact)/2.0 + 0.5)/float(sampfact)

      ; This is the desired location for the new source, just copying variables
      ;   here to make the code look simpler later on.
      x = xsrc[j]
      y = ysrc[j]

      ; Some rudimentary error checking
      if (x lt 0) or (x ge im_xsize) then begin
         t = string(im_xsize, format='(G0.0)')
         print, self+'Error. X-position out of bounds. (0 <= X < ' + t + ').'
         continue
      endif
      if (y lt 0) or (y ge im_ysize) then begin
         t = string(im_ysize, format='(G0.0)')
         print, self, 'Error. Y-position out of bounds. (0 <= X < ' + t + ').'
         continue
      endif

      ; Compute the fractional shift needed (in the original pixel space)
      xf = (x - xm0)
      xf = xf - fix(xf)
      yf = (y - ym0)
      yf = yf - fix(yf)

      ; Create the shift vector, this shift is in the sub-sampled units.
      svec = [xf,yf]*sampfact

      ; Shift the psf.
      spsf = sshift2d(psf, svec)

      ; Convolve PSF with circular function if requested.
      if n_elements(objrad) ne 0 then begin
         ; Compute size of kernel.
         nk = ceil(objrad[j]*sampfact - 0.5) * 2 + 1

         ; If kernel is bigger than one pixel then do the convolution.
         if nk gt 1 then begin
            kc = nk / 2
            idx=indgen(nk)
            unit=replicate(1,nk)
            tmpx=idx#unit
            tmpy=unit#idx
            kernel=pixwt(kc,kc,objrad[j]*sampfact,tmpx,tmpy)
            kernel=kernel/total(kernel)
            spsf=convol(spsf,kernel)
         endif
      endif

      ; Rebin the psf.
      fpsf = rebin(spsf, psf_xsizef/sampfact, psf_ysizef/sampfact)
      psfstat  = size(fpsf)

      ; Size of the rebinned PSF (matches output image grid).
      psf_xsize = psfstat[1]
      psf_ysize = psfstat[2]

      ; compute the two matching image areas for the paste
      i0 = fix(x-xm0)
      j0 = fix(y-ym0)
      i1 = i0+psf_xsize-1
      j1 = j0+psf_ysize-1
      ip0 = 0
      ip1 = psf_xsize-1
      jp0 = 0
      jp1 = psf_ysize-1
      if i0 lt 0 then begin
        adjust = abs(i0)
        i0  += adjust
        ip0 += adjust
      endif
      if j0 lt 0 then begin
        adjust = abs(j0)
        j0  += adjust
        jp0 += adjust
      endif
      if i1 ge 800 then begin
        adjust = i1-799
        i1  -= adjust
        ip1 -= adjust
      endif
      if j1 ge 800 then begin
        adjust = j1-799
        j1  -= adjust
        jp1 -= adjust
      endif

      ; Add the appropriate sub-section of the PSF to the output array.
      image[i0:i1,j0:j1] += inten[j]*fpsf[ip0:ip1,jp0:jp1]

   endfor

   if jitter_in gt 0.0 then begin
      if imgtype eq 4 then begin
         x=[-2.0,-1.,0.,1.0,2.0]
         y=[-2.0,-1.,0.,1.0,2.0]
         i=[1.0,1.0,1.0,1.0,1.0]
         jitter= jitter_in
         maxexp = 32./alog10(exp(1.0))
      endif else begin
         x=[-2.0D0,-1.D0,0.D0,1.0D0,2.0D0]
         y=[-2.0D0,-1.D0,0.D0,1.0D0,2.0D0]
         i=[1.0D0,1.0D0,1.0D0,1.0D0,1.0D0]
         jitter = double(jitter_in)
         maxexp = 302./alog10(exp(1.0))
      endelse
      rsq = (x^2#i + i#y^2)/jitter^2
      maxexp=2.0*maxexp
      rsq = rsq < maxexp
      z = where ( rsq eq maxexp, count)
      if verbose then begin
         print, 'rsq: ', rsq
         if count ne 0 then print, 'rsq: ', count, ' values truncated.'
      endif
      kernel = exp(-rsq/2.)
      kernel=kernel/total(kernel)
      if verbose then help,kernel
      if verbose then print,kernel
      image=convol(image, kernel)
   endif

   image = image + back

   if not new then in_image += image else in_image = image

end
